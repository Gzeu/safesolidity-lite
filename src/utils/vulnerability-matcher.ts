import { auditRules } from '../constants/audit-rules';
import { patterns } from '../constants/vulnerability-patterns';
import type { Vulnerability } from '../types/vulnerability.types';

export function matchVulnerabilities(source: string): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];
  
  function addVulnerability(id: string, description: string, severity = auditRules[id]?.severity || 'MEDIUM') {
    vulnerabilities.push({
      id,
      description,
      severity: severity as 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL',
      location: null
    });
  }
  
  if (auditRules.TX_ORIGIN?.enabled && patterns.txOrigin.test(source)) {
    addVulnerability('TX_ORIGIN', 'Folosirea tx.origin pentru autorizare este periculoasa. Foloseste msg.sender.');
  }
  
  if (auditRules.TIMESTAMP?.enabled && patterns.blockTimestamp.test(source)) {
    addVulnerability('TIMESTAMP', 'Dependinta de block.timestamp poate fi manipulata de mineri.');
  }
  
  if (auditRules.UNCHECKED_CALL?.enabled && patterns.callNoCheck.test(source)) {
    addVulnerability('UNCHECKED_CALL', 'Rezultatul address.call(...) nu este verificat.');
  }
  
  if (auditRules.REENTRANCY?.enabled && patterns.reentrancy.test(source) && !patterns.reentrancyProtection.test(source)) {
    addVulnerability('REENTRANCY', 'Posibila vulnerabilitate de reentrancy prin call() fara protectii.');
  }
  
  if (auditRules.ARITH_OVERFLOW?.enabled && patterns.arithmeticOps.test(source) && patterns.oldSolidity.test(source)) {
    addVulnerability('ARITH_OVERFLOW', 'Overflow/underflow posibil in versiuni Solidity <0.8 fara checked arithmetic.');
  }
  
  return vulnerabilities;
}
